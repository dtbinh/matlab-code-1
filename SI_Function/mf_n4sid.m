function [A, B, C, D] = mf_n4sid(u, y, k, n)
%==========================================================================
% ◎ システム同定 - N4SID法 (SISO,MIMO対応)
%==========================================================================
% [A, B, C, D] = mf_n4sid(u, y, k, n)
% u : 入力
% y : 出力
% k : データ行列の行数
% n : 状態変数の次数
% A(n*n), B(n*m), C(p*n), D(p*m) : 状態空間表現の行列

%--------------------------------------------------------------------------
% ● 入力と出力のデータ行列生成
%--------------------------------------------------------------------------
% SISOの時のデータ行列
% % 過去の入力
% tmp1 = u(:,1:k);
% tmp2 = u(:,k:end-k);
% Up = hankel(tmp1,tmp2);
% tmp1 = y(:,1:k);
% tmp2 = y(:,k:end-k);
% Yp = hankel(tmp1,tmp2);
% % 未来の入力
% tmp1 = u(:,k+1:2*k);
% tmp2 = u(:,2*k:end);
% Uf = hankel(tmp1,tmp2);
% tmp1 = y(:,k+1:2*k);
% tmp2 = y(:,2*k:end);
% Yf = hankel(tmp1,tmp2);

% MIMOの時のデータ行列（こちらを使う）
m = size(u,1);      % 入力の次数 uの1行目のサイズ
p = size(y,1);      % 出力の次数
km = k*m
kp = k*p
% 過去の入力
Up = zeros(m*k,size(u,2)-2*k + 1);
for i = 1:k
    Up(m*(i-1)+1:m*i,:) = u(:,i:size(u,2)-2*k+1 + i-1);
end
Yp = zeros(p*k,size(y,2)-2*k+1);
for i = 1:k
    Yp(p*(i-1)+1:p*i,:) = y(:,i:size(y,2)-2*k+1 + i-1);
end
% 未来の入力
Uf = zeros(m*k,size(u,2)-2*k+1);
for i = 1:k
    Uf(m*(i-1)+1:m*i,:) = u(:,i+k:size(u,2)-2*k+1 + i+k-1);
end
Yf = zeros(p*k,size(y,2)-2*k+1);
for i = 1:k
    Yf(p*(i-1)+1:p*i,:) = y(:,i+k:size(y,2)-2*k+1 + i+k-1);
end
N = size(Up,2);



%--------------------------------------------------------------------------
% ● LQ分解
%--------------------------------------------------------------------------
clear tmp1 tmp2;
Wp = [Up; Yp];
tmp1 = [Uf; Wp; Yf]; % [Uf; Up; Yp; Yf];でも可
[Q, L] = qr(tmp1', 0);
Q = Q';
L = L';
com_st = L(1,1); %component_standard : 基準要素
% for i = k+1:min(size(L))
%     if abs(L(i,i)) < abs(com_st * 10^(-4))
%         break;
%     end
% end
% L22 = L(k+1:3*k, k+1:i-1);
% L32 = L(3*k+1:end, k+1:i-1);
% size(L22)
% size(L32)

for i = km+1 : N
    if L(km+1 : 2*km+kp, i) < abs(com_st * 10^(-5))
        r = i-1;
        break;
    end
end
L22 = L(km+1 : 2*km+kp, km+1 : km+r);
L32 = L(2*km+kp+1 : 2*km+2*kp, km+1 : km+r);
size(L22)
size(L32)
       

% Th = L32 * (L22'*L22)^(-1)*L22' * Wp;
Th = L32 * pinv(L22) * Wp;

%--------------------------------------------------------------------------
% ● SVD
% n : 状態変数の次数
%--------------------------------------------------------------------------
[sU, sS, sV] = svd(Th);
sU1 = sU(:, 1:n);
sS1 = sS(1:n, 1:n)
sV1 = sV(:, 1:n);  % 転置であることに注意
% sU2 = sU(:, n+1:end);
% sS2 = sS(n+1:end, n+1:end);
% sV2 = sV(:, n+1:end);  % 転置であることに注意

%--------------------------------------------------------------------------
% ● 拡大可観測行列の算出
%--------------------------------------------------------------------------
Ok = sU1 * sqrt(sS1);

%--------------------------------------------------------------------------
% ● 状態ベクトルの算出
%--------------------------------------------------------------------------
Xk = (Ok'*Ok)^(-1)*Ok' * Th;

%--------------------------------------------------------------------------
% ● A,B,C,D の算出
%--------------------------------------------------------------------------
XY = [Xk(:, 2:end); y(:, k+1:end-k)]; % [Xk+1; Yk]
XU = [Xk(:, 1:end-1); u(:, k+1:end-k)]; % [Xk; Uk]
res = (XY*XU')*(XU*XU')^(-1);
A = res(1:n, 1:n);
B = res(1:n, 1+n:end);
C = res(1+n:end, 1:n);
D = res(1+n:end, 1+n:end);

end

