function [A, B, C, D] = mf_clmoesp(r, u, y, k, n)
%==========================================================================
% ◎ システム同定 - CL-MOESP法
%==========================================================================
% [A, B, C, D] = mf_clmoesp(r, u, y, k, n)
% r : 目標値信号
% u : 入力信号
% y : 出力信号
% k : データ行列の行数
% n : 状態変数の次数
% A(n*n), B(n*m), C(p*n), D(p*m) : 状態空間表現の行列

%--------------------------------------------------------------------------
% ● 入力と出力のデータ行列生成
%--------------------------------------------------------------------------
m = size(u,1);      % 入力と目標値の次数 uの1行目のサイズ
p = size(y,1);      % 出力の次数
km = k*m;
kp = k*p;
% 過去のデータ
Rp = zeros(m*k,size(r,2)-2*k + 1);
for i = 1:k
    Rp(m*(i-1)+1:m*i,:) = r(:,i:size(r,2)-2*k+1 + i-1);
end
Up = zeros(m*k,size(u,2)-2*k + 1);
for i = 1:k
    Up(m*(i-1)+1:m*i,:) = u(:,i:size(u,2)-2*k+1 + i-1);
end
Yp = zeros(p*k,size(y,2)-2*k+1);
for i = 1:k
    Yp(p*(i-1)+1:p*i,:) = y(:,i:size(y,2)-2*k+1 + i-1);
end
% 未来のデータ
Rf = zeros(m*k,size(r,2)-2*k+1);
for i = 1:k
    Rf(m*(i-1)+1:m*i,:) = r(:,i+k:size(r,2)-2*k+1 + i+k-1);
end
Uf = zeros(m*k,size(u,2)-2*k+1);
for i = 1:k
    Uf(m*(i-1)+1:m*i,:) = u(:,i+k:size(u,2)-2*k+1 + i+k-1);
end
Yf = zeros(p*k,size(y,2)-2*k+1);
for i = 1:k
    Yf(p*(i-1)+1:p*i,:) = y(:,i+k:size(y,2)-2*k+1 + i+k-1);
end
N = size(Up,2);


%--------------------------------------------------------------------------
% ● LQ分解
%--------------------------------------------------------------------------
tmp1 = [Rp; Rf; Up; Uf; Yf];
[Q, L] = qr(tmp1', 0);
clear tmp1
Q = Q';
L = L';
com_st = L(1,1);
for i = 1 : N
    if abs(L(1 : km, i)) < abs(com_st * 10^(-5))
        c1 = i-1;
        break;
    end
end
c1
for j = i : N
    if abs(L(km+1 : 2*km, j)) < abs(com_st * 10^(-5))
      c2 = j - 1;
      break;
    end
end
L31 = L(2*km+1 : 3*km, 1 : c1);
L32 = L(2*km+1 : 3*km, c1+1 : c2);
L41 = L(3*km+1 : 4*km, 1 : c1);
L42 = L(3*km+1 : 4*km, c1+1 : c2);
L51 = L(4*km+1 : 4*km+kp, 1 : c1);
L52 = L(4*km+1 : 4*km+kp, c1+1 : c2);

%--------------------------------------------------------------------------
% ● gamma計算
%--------------------------------------------------------------------------
P1 = L31 - (L31*L41' + L32*L42')*(L41*L41' + L42*L42')^(-1)*L41;
P2 = L32 - (L31*L41' + L32*L42')*(L41*L41' + L42*L42')^(-1)*L42;
gamma = (L51*P1' + L52*P2')*sqrtm((P1*P1' + P2*P2')^(-1));

%--------------------------------------------------------------------------
% ● SVD (sU*sS*sV' = gamma)
% n : 状態変数の次数
%--------------------------------------------------------------------------
[sU, sS, sV] = svd(gamma);
sU1 = sU(:, 1:n);
sS1 = sS(1:n, 1:n)
sV1 = sV(:, 1:n);  % 転置であることに注意
sU2 = sU(:, n+1:end);

%--------------------------------------------------------------------------
% ● A,B,C,D の算出
%--------------------------------------------------------------------------

C = sU1(1:p, :);
A = pinv(sU1(1:p*(k-1),:))*sU1(p+1:kp,:);
sU2T = sU2';
% sU2T((i-1)*p+1:i*p) %alpha i
sBT = sU2T*(L51*L41' + L52*L42')*(L41*L41' + L42*L42')^(-1);
% sBT((i-1)*m+1:i*m) %beta i
DB1 = [eye(p) zeros(p,n); zeros((k-1)*p,p) sU1(1:(k-1)*p,:)];
DB2 = zeros(size(sU2T,1)*k, kp); % ゼロで行列全体を定義する
DB3 = zeros(size(sBT,1)*k, m);   % ゼロで行列全体を定義する
alpha_r = size(sU2T,1); % αの行数
alpha_c = p;            % αの列数
beta_r = size(sBT,1);   % βの行数
beta_c =  m;            % βの列数
for i = 1:k
    for j = 1:i
        ii = i-(j-1);
        jj = j;
        DB2((ii-1)*alpha_r+1:ii*alpha_r, (jj-1)*alpha_c+1:jj*alpha_c) = sU2T(:, (i-1)*p+1:i*p);
    end
    DB3((i-1)*beta_r+1:i*beta_r,:) = sBT(:, (i-1)*m+1:i*m);
end
DB = pinv(DB1)*pinv(DB2)*DB3;
D = DB(1:p, : );
B = DB(p+1:p+n, : );
