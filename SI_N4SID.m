%==========================================================================
% ◎ システム同定 - N4SID法
%==========================================================================
clear
close all

%--------------------------------------------------------------------------
% ● パラメータ
%--------------------------------------------------------------------------
% M系列
mP = 5; % M系列のmP段シフトレジスタ
mk = 2; % 最終段以外にフィードバックさせる信号 (-mk 番目)

%--------------------------------------------------------------------------
% ● M系列信号生成
%--------------------------------------------------------------------------
x = randi([0 1], mP, 1);    % 状態の初期値をランダムに決定
x = [1 1 1 1 1]';
u = zeros(2^mP-1, 1);       % 出力変数の定義
for i = 1:2^mP-1            % 信号の生成
    x = [xor(x(mk),x(end));x(1:end-1)]; %フィードバック
    u(i) = x(1);
end
for i = 1:2^mP - 1          % 2値信号の値を0,1から-1,1に変更
    if u(i) == 1
        u(i)=1;
    else
        u(i)=-1;
    end
end

%--------------------------------------------------------------------------
% ● 伝達関数と出力信号の生成
%--------------------------------------------------------------------------
% パラメータ
m = 1;      %入力の数
p = 1;      %出力の数
sample = 1; %サンプリング周波数
n = 1;      %状態変数の次数
k = 4;      %データ行列の行数

% フィボナッチ数列
% num = [1 0];              %伝達関数分子
% den = [1 -1 -1];            %伝達関数分母
% dP = tf(num,den,sample);

% 連続系を離散系に双一次変換したもの
num = [1];                  %伝達関数分子
den = [1 5];                %伝達関数分母
cP = tf(num,den);
dP = c2d(cP,sample,'tustin');
[y,t] = lsim(dP, u, 0:1:numel(u)-1);
% stem(t,u)
% hold on
% stem(t,y)

%--------------------------------------------------------------------------
% ● 入力と出力のデータ行列生成
% k : データ行列の行数
%--------------------------------------------------------------------------
% 過去の入力
tmp1 = u(1:k);
tmp2 = u(k:end-k);
Up = hankel(tmp1,tmp2);
tmp1 = y(1:k);
tmp2 = y(k:end-k);
Yp = hankel(tmp1,tmp2);
% 未来の入力
tmp1 = u(k+1:2*k);
tmp2 = u(2*k:end);
Uf = hankel(tmp1,tmp2);
tmp1 = y(k+1:2*k);
tmp2 = y(2*k:end);
Yf = hankel(tmp1,tmp2);

%--------------------------------------------------------------------------
% ● LQ分解
%--------------------------------------------------------------------------
clear tmp1 tmp2;
Wp = [Up; Yp];
tmp1 = [Uf; Wp; Yf]; % [Uf; Up; Yp; Yf];でも可
[Q, L] = qr(tmp1', 0);
Q = Q';
L = L';
com_st = L(1,1); %component_standard : 基準要素
for i = k+1:min(size(L))
    if abs(L(i,i)) < abs(com_st * 10^(-4))
        break;
    end
end
L22 = L(k+1:3*k, k+1:i-1);
L32 = L(3*k+1:end, k+1:i-1);

Th = L32 * (L22'*L22)^(-1)*L22' * Wp;

%--------------------------------------------------------------------------
% ● SVD
% n : 状態変数の次数
%--------------------------------------------------------------------------
[sU, sS, sV] = svd(Th);
sU1 = sU(:, 1:n);
sS1 = sS(1:n, 1:n);
sV1 = sV(:, 1:n);  % 転置であることに注意
% sU2 = sU(:, n+1:end);
% sS2 = sS(n+1:end, n+1:end);
% sV2 = sV(:, n+1:end);  % 転置であることに注意

%--------------------------------------------------------------------------
% ● 拡大可観測行列の算出
%--------------------------------------------------------------------------
Ok = sU1 * sqrt(sS1);

%--------------------------------------------------------------------------
% ● 状態ベクトルの算出
%--------------------------------------------------------------------------
Xk = (Ok'*Ok)^(-1)*Ok' * Th;

%--------------------------------------------------------------------------
% ● A,B,C,D の算出
%--------------------------------------------------------------------------
XY = [Xk(2:end); y(k+1:end-k)']; % [Xk+1; Yk]
XU = [Xk(1:end-1); u(k+1:end-k)']; % [Xk; Uk]
res = (XY*XU')*(XU*XU')^(-1);
A = res(1:n, 1:n);
B = res(1:n, 1+n:end);
C = res(1+n:end, 1:n);
D = res(1+n:end, 1+n:end);

%--------------------------------------------------------------------------
% ● 伝達関数の算出
%--------------------------------------------------------------------------
[num den] = ss2tf(A,B,C,D);
dP_est = tf(num,den,sample);

dP
dP_est

% %--------------------------------------------------------------------------
% % ● プロット
% %--------------------------------------------------------------------------
% % fig1 = figure(1);
% % hold on;
% % [vec,t] = impulse(dP,5);
% % [vec2,t] = impulse(dP_est,5);
% % 
% % stem(t,vec);
% % stem(t,vec2);
% % 
% % set(gca,'FontName','arial','FontSize',14)
% % xlabel('time [s]','FontName','arial','FontSize',16)
% % ylabel('out','FontName','arial','FontSize',16)
% % legend('true','estimate')
% % set(legend,'FontName','arial','FontSize',14)





